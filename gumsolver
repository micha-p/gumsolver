#! /usr/bin/lua

require 'display'
require 'expressions'
require 'process'
require 'csv'
require 'table-mode'
require 'constraints_with_values'
require 'dump'
require 'mask'

-- overwrite !!!!
function printprobe (me, value)
   if MASK then 
      printmaskline (me["name"], value)
   else
      if not MUTE then
         if TRACE then
            if DEBUG then 
               warn (short(me), PRINT16 (me["name"]), value)
            else
               print (short(me), PRINT16 (me["name"]), value)
            end
         else      
            if DEBUG then 
               warn (PRINT16 (me["name"]), value)
            else
               print (PRINT16 (me["name"]), value)
            end
         end
      end
   end
end
    

VERSION = "0.3.0"
SCRIPT=arg and string.match(arg[0],"[^%w%-]*([%w%-]*)$")
INFILE=nil
TABLE=nil 
PROMPT=nil
RELATIVE=nil
DELIMITER="\t"
RECORD=nil
DEBUG=nil
MASK=nil
CONNECTORS={}    		-- name: connector (explicitly defined) 
SUBEXPRESSIONS={} 	        -- connectors of subexpressions 
CONSTRAINTS={}   		-- hint or number : constraint 
PROBES={}
RECORDS={}			-- number : record
DEFINITIONS={}			-- number : string
COLNAMES={}			-- number : string

cadd   = function (x,y) local z = make_connector("+"); table.insert(SUBEXPRESSIONS,z); c=SUM   (x,y,z); table.insert(CONSTRAINTS,c);return z end
csub   = function (x,y) local z = make_connector("-"); table.insert(SUBEXPRESSIONS,z); c=DIFF  (x,y,z); table.insert(CONSTRAINTS,c);return z end
cmul   = function (x,y) local z = make_connector("*"); table.insert(SUBEXPRESSIONS,z); c=PROD  (x,y,z); table.insert(CONSTRAINTS,c);return z end
cdiv   = function (x,y) local z = make_connector("/"); table.insert(SUBEXPRESSIONS,z); c=RATIO (x,y,z); table.insert(CONSTRAINTS,c);return z end
cval   = function (x  ) local z = make_connector("#"); table.insert(SUBEXPRESSIONS,z); z.set("constant", x); return z end

help={}
help[ 1]="gumsolver -- resolving equations by propagation of uncertainties"
help[ 2]="usage:    gumsolver [options] [-f file]"
help[ 3]="options: -d delimiter   field separator for input"
help[ 4]="         -a             start displaying absolute uncertainties (default)"
help[ 5]="         -r             start displaying relative uncertainties"
help[ 6]="         -D             debug messages"
help[ 7]="         -T             read input horizontally as tables"
help[ 8]="         -R             Restrict output to records"
help[ 9]="         -f             use file for input"
help[10]="         -I             interactive (readline wrapper suggested)"
help[11]="         -J             interactive (nonscrolling mask)"
help[12]="         -v             display version"
help[13]="         -h             this help"

while arg and arg[1] do
   TABLE    = TABLE    or arg[1]=="-T"
   PROMPT   = PROMPT   or arg[1]=="-I" and "> "
   DEBUG    = DEBUG    or arg[1]=="-D"
   MASK     = MASK     or arg[1]=="-J"
   RECORD   = RECORD   or arg[1]=="-R"
   RELATIVE = RELATIVE or arg[1]=="-r" or arg[1]=="-a" and nil
   if arg[1]=="-f" then 
      table.remove(arg,1)
      INFILE = assert(io.open(arg[1]))
   end
   if arg[1]=="-d" then 
      table.remove(arg,1)
      DELIMITER = ( arg[1]=="\\t" and "\t" or arg[1])
   end
   if arg[1]=="-h" then 
      for k,v in ipairs (help) do print(v) end; return      
   end
   if arg[1]=="-v" then 
      print ("version "..VERSION); return     
   end
   table.remove(arg,1)
end


function process_infile(filehandle)
   for line in io.input(filehandle):lines() do 
      if line:find("^#Q") then print(); os.exit() end
      process_input (line)
   end
return not nil
end

function process_include(f)
   if DEBUG then warn("INCLUDE\t",f,"\n") end
   for line in io.input(filehandle):lines() do 
      if line:find("^#Q") then break end
      process_input (line)
   end
return not nil
end


function process_stdin()
   while true do
      if PROMPT then io.write(PROMPT) end 
      local line = io.read()
      if line==NIL or line:find("^#Q") then break end
      process_input (line)
   end
   print()
return not nil
end


if TABLE then
   process_table(CONNECTORS, DELIMITER, INFILE)
else
   if PROMPT then io.write(SCRIPT.." version "..VERSION) end
   if DEBUG  then warn("   DEBUG MODE\n") end
   if PROMPT then print() end
   if MASK   then print("\27[H\27[J") end
   if INFILE then 
      local temp = io.input()
      process_infile(INFILE) 
      io.close(INFILE)
      io.input(temp)
   end
   if MASK then 
      navigate() 
   else  
      process_stdin()
   end
end



--[[
process_line ("F = ( (9 / 5 ) * C ) + 32")
process_line ("K = C + 273.15")
process_line ("R = 80 * (C / 100)")


process_line ("C=25")
process_line ("F=212")
process_line ("C")
process_line ("F=212")
process_line ("F")
process_line ("K=0")
process_line ("K")
process_line ("R=80")
process_line ("R")
process_line ("R=0")
process_line ("R")
process_line ("C=100") 
dump_connectors()
--]]


   
   
