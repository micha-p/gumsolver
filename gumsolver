#! /usr/bin/lua

dofile ("display.lua")
dofile ("constraints_with_values.lua")
dofile ("table-mode.lua")
dofile ("debug.lua")

VERSION = "1.0"
SCRIPT=string.match(arg[0],"[^%w%-]*([%w%-]*)$")
TABLE=nil 
PROMPT=nil
RELATIVE=nil
DELIMITER=","
EQUAL = function (a,b) return a.v == b.v and a.D2 == b.D2 end 
PRINT = function (r)
   local rel  = function () return best(100 * math.sqrt(r.d2),2) .. "%" end
   local abs  = function () return best(math.sqrt(r.D2),3) end
 return best(r.v,4) ..  " ± " .. (RELATIVE and rel() or abs ()) 
end 

function best (n, precision) 
   if n==0 then
      return "0"
   else 
      precision = precision or 5
      magnitude = math.floor(math.log10(math.abs(n)))+1
      shift     = 10^(precision - magnitude)  
      result    = math.floor( n*shift +0.5) / shift
      return magnitude>precision and string.format("%.f", result) 
             or 
             magnitude<1 and string.format("%."..tonumber(precision-magnitude).."f", result) 
             or
             result
   end
end

help={}
help[1]="gumsolver -- resolving equations by propagation of uncertainties"
help[2]="usage:    gumsolver [options] [file]"
help[3]="options:  -t             table mode"
help[4]="          -d delimiter   column separator for table"
help[5]="          -i             interactive (use readline wrapper)"
help[6]="          -D             debug messages"
help[7]="          -a             start displaying absolute uncertainties (default)"
help[8]="          -r             start displaying relative uncertainties"
help[9]="          -v             display version"
help[10]="         -h             this help"

while arg[1] do
   TABLE  = TABLE  or arg[1]=="-t"
   PROMPT = PROMPT or arg[1]=="-i" and "> "
   DEBUG  = DEBUG  or arg[1]=="-D"
   if arg[1]=="-d" then 
      table.remove(arg,1)
      DELIMITER = ( arg[1]=="\\t" and "\t" or arg[1])
   end
   if arg[1]=="-r" then 
      RELATIVE = not nil
   end
   if arg[1]=="-a" then 
      RELATIVE = nil
   end
   if arg[1]=="-h" then 
      for k,v in ipairs (help) do print(v) end; return      
   end
   if arg[1]=="-v" then 
      print ("version "..VERSION); return     
   end
   table.remove(arg,1)
end

function ensure_symbol_and_probe(name)
   if not CONNECTORS[name] then 
      if DEBUG then print2stderr (name, "!", "") end
      CONNECTORS[name]=make_connector(name)
   end
   if not CONSTRAINTS[name] then 
      if TABLE then
         if DEBUG then PROBES[name] = probe2stderr (name, CONNECTORS[name]) end
      else
         PROBES[name] = probe (name, CONNECTORS[name]) 
      end
   end
return CONNECTORS[name]
end

function process_line (c, input)   
   local name=extract_name(input)
   local expr=extract_expr(input)
   -- a known name ( c[name] not equal nil) should not prevent any new constraints
   -- therefore it is neccessary to distinguish between setting of new values or submitting new constraints
   -- moreover, the left side should not be overwritten

   if not name then error ("No name found for left-side: "..input) end
   
   -- a) ensure connector and probe for left-sided name
   ensure_symbol_and_probe(name)

   -- b) process right side

   if expr then
      if string.find (expr, "[%a*/%(%)]") then
         if DEBUG then print2stderr (name, ":=", expr) end
         local e = process_expr (expr)
         CONSTRAINTS[name.."="]=pipe(c[name],e)
      elseif string.match (expr, "^[%s%d%.%_%±%+%-%%]*$") then
         local val
         val = vreader(expr)
         if DEBUG then print2stderr (name, ":", RELATIVE and val.rel() or val.abs()) end
            run (c, c[name], val, not relflag and err, relflag and err/100)
         else
            error ("Can't distinguish between formula or value: "..expr)
         end
   else
      if DEBUG then print2stderr (name, ":", "?") end
      run (c, c[name])
   end
end


if TABLE then
   process_table(CONNECTORS, DELIMITER)
else
   if PROMPT and not DEBUG then io.write(SCRIPT.." version "..VERSION.."\n") end
   if DEBUG  then io.stderr:write(SCRIPT.." version "..VERSION.."   DEBUG MODE\n") end
   if PROMPT then io.write(PROMPT) end
   for line in io.lines() do 
      line = line:match("%s*(.*)$")
      if line:find("^!Q") then break end
      if line:find("^!P") then print (line:match("^!PR?I?N?T? (.*)$") or "") ; line="" end
      if line:find("^!R") then RELATIVE=not nil ; line="" end
      if line:find("^!A") then RELATIVE=nil     ; line="" end
      if line:find("^!D.*") then dump_connectors(CONNECTORS); line="" end
      line = line:find("#") and line:match("([^#]*)#.*$") or line
      if line:len() > 0 then process_line (CONNECTORS, line) end
      if PROMPT then io.write(PROMPT) end 
   end
   print()
end






   
   
