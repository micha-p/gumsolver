#! /usr/bin/lua

require 'display'
require 'expressions'
require 'csv'
require 'table-mode'
require 'constraints_with_values'
require 'dump'

VERSION = "0.1.0"
SCRIPT=arg and string.match(arg[0],"[^%w%-]*([%w%-]*)$")
TABLE=nil 
PROMPT=nil
RELATIVE=nil
DELIMITER=","
RECORD=nil
DEBUG=nil
CONNECTORS={}    		-- name: connector (explicitly defined) 
SUBEXPRESSIONS={} 	        -- connectors of subexpressions 
CONSTRAINTS={}   		-- hint or number : constraint 
PROBES={}
RECORDS={}			-- number : record
DEFINITIONS={}			-- number : string
COLNAMES={}			-- number : string

cadd   = function (x,y) local z = make_connector("+"); table.insert(SUBEXPRESSIONS,z); c=SUM   (x,y,z); table.insert(CONSTRAINTS,c);return z end
csub   = function (x,y) local z = make_connector("-"); table.insert(SUBEXPRESSIONS,z); c=DIFF  (x,y,z); table.insert(CONSTRAINTS,c);return z end
cmul   = function (x,y) local z = make_connector("*"); table.insert(SUBEXPRESSIONS,z); c=PROD  (x,y,z); table.insert(CONSTRAINTS,c);return z end
cdiv   = function (x,y) local z = make_connector("/"); table.insert(SUBEXPRESSIONS,z); c=RATIO (x,y,z); table.insert(CONSTRAINTS,c);return z end
cval   = function (x  ) local z = make_connector("#"); table.insert(SUBEXPRESSIONS,z); z.set("constant", x); return z end

help={}
help[ 1]="gumsolver -- resolving equations by propagation of uncertainties"
help[ 2]="usage:    gumsolver [options] [file]"
help[ 3]="options: -d delimiter   field separator for input"
help[ 4]="         -a             start displaying absolute uncertainties (default)"
help[ 5]="         -r             start displaying relative uncertainties"
help[ 6]="         -D             debug messages"
help[ 7]="         -T             read tables horizontally"
help[ 8]="         -R             Restrict output to records"
help[ 9]="         -i             interactive (use readline wrapper)"
help[10]="         -v             display version"
help[11]="         -h             this help"

while arg and arg[1] do
   TABLE    = TABLE    or arg[1]=="-T"
   PROMPT   = PROMPT   or arg[1]=="-I" and "> "
   DEBUG    = DEBUG    or arg[1]=="-D"
   RECORD   = RECORD   or arg[1]=="-R"
   RELATIVE = RELATIVE or arg[1]=="-r" or arg[1]=="-a" and nil
   if arg[1]=="-d" then 
      table.remove(arg,1)
      DELIMITER = ( arg[1]=="\\t" and "\t" or arg[1])
   end
   if arg[1]=="-h" then 
      for k,v in ipairs (help) do print(v) end; return      
   end
   if arg[1]=="-v" then 
      print ("version "..VERSION); return     
   end
   table.remove(arg,1)
end

function ensure_symbol_and_probe(name, connector)
   if not CONNECTORS[name] then 
      if DEBUG then print2stderr (PRINT16 (name), "!") end
      CONNECTORS[name]=connector or make_connector(name)
   end
   if not PROBES[name] then 
      if TABLE or RECORD then
         if DEBUG then PROBES[name] = probe2stderr (name, CONNECTORS[name]) end
      else
         PROBES[name] = probe (name, CONNECTORS[name]) 
      end
   end
return CONNECTORS[name]
end
    
function process_line (input)   
   local name=extract_name(input)
   local expr=extract_expr(input)

   if not name then return end
   
   if expr then
      if string.match (expr, NAMEPATTERN.."_[%d]+") then          --backreference
         local entry  = string.match (expr, NAMEPATTERN) 
         local recnum = tonumber(string.match (expr, "_([%d]+)")) 
         local rec = assert (RECORDS[recnum], "Invalid record number: "..recnum)
         run(CONNECTORS, ensure_symbol_and_probe(name), rec[entry])
      elseif  string.find (expr, "[%a*/%(%)]") then               --expression
         if DEBUG then print2stderr (name, expr.."!") end
         DEFINITIONS[name]=expr
         local e = EVAL(ensure_symbol_and_probe, order(parse(expr)))
         if CONNECTORS[name] then
            CONSTRAINTS[name.."="]=pipe(CONNECTORS[name],e,RET,RET)
         else
            ensure_symbol_and_probe(name, e)
         end
      elseif string.match (expr, "^[%s%d%.%_%Â±%+%-%%]*$") then    --value
         local val
         val = vreader(expr)
         if DEBUG then print2stderr (name, expr.." (user)") end
         run (c, ensure_symbol_and_probe(name), val)
      else
         error ("Can't resolve right side: "..expr)
      end
   else
      run(CONNECTORS, CONNECTORS[name])
   end
end


function content(line)
return string.match(line:match("^([^#]*)#?.*$"), "^%s*(.*)%s*$")
end


function process_directive(line)
   local function set (v)
      RELATIVE=v
   return not nil
   end
   local function trace()
      TRACE=not TRACE
   return not nil
   end
return line:find("^#P") and (TABLE or RECORD) and  warn (line:match("^!PR?I?N?T? (.*)$") or "")
       or
       line:find("^#P") and  (print (line:match("^#PR?I?N?T? (.*)$") or "") or not nil)
       or
       line:find("^#A") and set (nil)
       or
       line:find("^#I") and process_input(line:match("^#IN?C?L?U?D?E?%s+([%S]+)")) and (print() or not nil)
       or
       line:find("^#O") and record_connectors()
       or
       line:find("^#RECO?R?D?") and record_connectors()
       or
       line:find("^#R") and set(not nil)
       or
       line:find("^#TRA?C?E?") and trace()
       or
       line:find("^#T") and tabulate_records()
       or
       line:find("^#D") and dump_connectors()
end

function process_input(file)
   function cycle(line)
      if line:find("^#[A-Z]") then
         process_directive(line)
      else
         process_line(content(line))
      end
      if PROMPT then io.write(PROMPT) end 
   end
   if file then 
      for line in io.lines(file) do cycle (line) end
   else
      for line in io.lines() do if line:find("^#Q") then break else cycle (line) end end
   end
return not nil
end

if TABLE then
   process_table(CONNECTORS, DELIMITER)
else
   if PROMPT and not DEBUG then io.write(SCRIPT.." version "..VERSION.."\n") end
   if DEBUG  then io.stderr:write(SCRIPT.." version "..VERSION.."   DEBUG MODE\n") end
   if PROMPT then io.write(PROMPT) end
   process_input()
   print()
end


--[[
process_line ("F = ( (9 / 5 ) * C ) + 32")
process_line ("K = C + 273.15")
process_line ("R = 80 * (C / 100)")


process_line ("C=25")
process_line ("F=212")
process_line ("C")
process_line ("F=212")
process_line ("F")
process_line ("K=0")
process_line ("K")
process_line ("R=80")
process_line ("R")
process_line ("R=0")
process_line ("R")
process_line ("C=100") 
dump_connectors()
--]]


   
   
