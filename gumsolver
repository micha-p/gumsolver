#! /usr/bin/lua

dofile ("display.lua")
dofile ("constraints_with_values.lua")
dofile ("table-mode.lua")

VERSION = "1.0"
SCRIPT=string.match(arg[0],"[^%w%-]*([%w%-]*)$")
TABLE=nil 
DEBUG=nil
PROMPT=nil
RELATIVE=nil
DELIMITER=","
CONNECTORS={}

help={}
help[1]="gumsolver -- resolving equations by propagation of uncertainties"
help[2]="usage:    gumsolver [options] [file]"
help[3]="options:  -t             table mode"
help[4]="          -d delimiter   column separator for table"
help[5]="          -i             interactive (use readline wrapper)"
help[6]="          -D             debug messages"
help[7]="          -a             start displaying absolute uncertainties (default)"
help[8]="          -r             start displaying relative uncertainties"
help[9]="          -v             display version"
help[10]="         -h             this help"

while arg[1] do
   TABLE  = TABLE  or arg[1]=="-t"
   PROMPT = PROMPT or arg[1]=="-i" and "> "
   DEBUG  = DEBUG  or arg[1]=="-D"
   if arg[1]=="-d" then 
      table.remove(arg,1)
      DELIMITER = ( arg[1]=="\\t" and "\t" or arg[1])
   end
   if arg[1]=="-r" then 
      RELATIVE = not nil
   end
   if arg[1]=="-a" then 
      RELATIVE = nil
   end
   if arg[1]=="-h" then 
      for k,v in ipairs (help) do print(v) end; return      
   end
   if arg[1]=="-v" then 
      print ("version "..VERSION); return     
   end
   table.remove(arg,1)
end



function process_line (c, input)   
   local name=input:match("%s*([%a][%w%-]*)%s*=?")
   local expr=input:match(".*=%s*(.*)%s*$")
   if c[name] then
         if c[expr] then
            if DEBUG then print2stderr (name, ":", expr) end
            pipe(c[name],c[expr])
         elseif expr then
            if DEBUG then print2stderr (name, ":", expr) end
            run (c, c[name], vreader(expr))
         else
            if DEBUG then print2stderr (name, ":", "?") end
            run (c, c[name])
         end
   else 
      if expr then
         if DEBUG then print2stderr (name, ":", expr) end
         probe (name, process_formula (c, input))
      else
         if DEBUG then print2stderr (name, ":", "?") end
         c[name]=make_connector("")
         probe (name, c[name])
      end
   end 
end


function dump_connectors() 
   function short (table)
   return string.gsub (tostring(table),"table: ","")
   end

   for k,v in pairs (CONNECTORS) do 
      value=(v.get())
      informant=(v.value())
      ltable=(v.listeners())
      if DEBUG then 
         io.write (short(v), "\t") 
         for k,l in pairs(ltable) do io.write (informant == l and "!" or "", short(l)," ") end 
         io.write ("\t") 
      end    
      print (k, 
             (v.info()) or "", 
             informant == 1 and "user" or "",
             informant and RELATIVE and value.rel() or informant and value.abs() or "")
   end
end





if TABLE then
   process_table(CONNECTORS, DELIMITER)
else
   if PROMPT and not DEBUG then io.write(SCRIPT.." version "..VERSION.."\n") end
   if DEBUG  then io.stderr:write(SCRIPT.." version "..VERSION.."   DEBUG MODE\n") end
   if PROMPT then io.write(PROMPT) end
   for line in io.lines() do 
      line = line:match("%s*(.*)$")
      if line:find("^!Q") then break end
      if line:find("^!P") then print (line:match("^!PR?I?N?T? (.*)$") or "") ; line="" end
      if line:find("^!R") then RELATIVE=not nil ; line="" end
      if line:find("^!A") then RELATIVE=nil     ; line="" end
      if line:find("^!D.*") then dump_connectors(); line="" end
      line = line:find("#") and line:match("([^#]*)#.*$") or line
      if line:len() > 0 then process_line (CONNECTORS, line) end
      if PROMPT then io.write(PROMPT) end 
   end
   print()
end






   
   
