#! /usr/bin/lua

dofile ("display.lua")
dofile ("constraints_with_values.lua")
dofile ("table-mode.lua")


VERSION = "1.0"
SCRIPT=string.match(arg[0],"[^%w%-]*([%w%-]*)$")
TABLE=nil 
DEBUG=nil
PROMPT=nil
RELATIVE=nil
DELIMITER=","
CONNECTORS={}
EQUAL = function (a,b) return a.v == b.v and a.D2 == b.D2 end 
PRINT = function (r)
   local rel  = function () return best(100 * math.sqrt(r.d2),2) .. "%" end
   local abs  = function () return best(math.sqrt(r.D2),3) end
 return best(r.v,4) ..  " ± " .. (RELATIVE and rel() or abs ()) 
end 

function best (n, precision) 
   if n==0 then
      return "0"
   else 
      precision = precision or 5
      magnitude = math.floor(math.log10(math.abs(n)))+1
      shift     = 10^(precision - magnitude)  
      result    = math.floor( n*shift +0.5) / shift
      return magnitude>precision and string.format("%.f", result) 
             or 
             magnitude<1 and string.format("%."..tonumber(precision-magnitude).."f", result) 
             or
             result
   end
end

help={}
help[1]="gumsolver -- resolving equations by propagation of uncertainties"
help[2]="usage:    gumsolver [options] [file]"
help[3]="options:  -t             table mode"
help[4]="          -d delimiter   column separator for table"
help[5]="          -i             interactive (use readline wrapper)"
help[6]="          -D             debug messages"
help[7]="          -a             start displaying absolute uncertainties (default)"
help[8]="          -r             start displaying relative uncertainties"
help[9]="          -v             display version"
help[10]="         -h             this help"

while arg[1] do
   TABLE  = TABLE  or arg[1]=="-t"
   PROMPT = PROMPT or arg[1]=="-i" and "> "
   DEBUG  = DEBUG  or arg[1]=="-D"
   if arg[1]=="-d" then 
      table.remove(arg,1)
      DELIMITER = ( arg[1]=="\\t" and "\t" or arg[1])
   end
   if arg[1]=="-r" then 
      RELATIVE = not nil
   end
   if arg[1]=="-a" then 
      RELATIVE = nil
   end
   if arg[1]=="-h" then 
      for k,v in ipairs (help) do print(v) end; return      
   end
   if arg[1]=="-v" then 
      print ("version "..VERSION); return     
   end
   table.remove(arg,1)
end



function process_line (c, input)   
   local name=extract_name(input)
   local expr=extract_expr(input)
   if c[name] then
         if c[expr] then
            if DEBUG then print2stderr (name, ":", expr) end
            pipe(c[name],c[expr])
         elseif expr then
            if string.find (expr, "[%a*/%(%)]") then
               if DEBUG then print2stderr (name, ":=", expr) end
               process_formula (c, input)
            else
               local val, err, relflag = vreader(expr) --vreader does not check percent
               if DEBUG then print2stderr (name, ":", val.." ± "..err..relflag) end
               run (c, c[name], val, not relflag and err, relflag and err/100)
            end
         else
            if DEBUG then print2stderr (name, ":", "?") end
            run (c, c[name])
         end
   else 
      if expr then
         if DEBUG then print2stderr (name, ":=", expr) end
         process_formula (c, input)
      else
         if DEBUG then print2stderr (name, ":", "?") end
         c[name]=make_connector("")
      end
      probe (name, c[name])
   end 
end


function dump_connectors(CONNECTORS) 

   local tablestack={}
   
   local function short (t)
      local key = table.find (tablestack, t)
      if key then
         return key 
      else
         table.insert (tablestack, t)
         return #tablestack
      end
   end
  
   local keys={}
   for k,v in pairs(CONNECTORS) do table.insert(keys, k) end
   if not DEBUG then table.sort(keys) end
   for i,key in pairs (keys) do 
      local v = CONNECTORS[key]
      informant=(v.value())
      ltable=(v.listeners())
      if DEBUG then 
         io.write (short(v), "\t") 
         for k,l in pairs(ltable) do io.write (informant == l and "!" or "", short(l)," ") end 
         -- TODO: Better print into string and adjust length 
         if #ltable < 3 or #ltable == 3 and not table.find (ltable, informant) then io.write ("\t") end
         if #ltable < 5 then io.write ("\t") end
         io.write ("\t") 
      end    
      print (key .. (string.len(key) < 8 and "\t" or ""), 
             (v.info()) or "", 
             informant == 1 and "user" or "",
             informant and PRINT(v.get()) or "")
   end
end





if TABLE then
   process_table(CONNECTORS, DELIMITER)
else
   if PROMPT and not DEBUG then io.write(SCRIPT.." version "..VERSION.."\n") end
   if DEBUG  then io.stderr:write(SCRIPT.." version "..VERSION.."   DEBUG MODE\n") end
   if PROMPT then io.write(PROMPT) end
   for line in io.lines() do 
      line = line:match("%s*(.*)$")
      if line:find("^!Q") then break end
      if line:find("^!P") then print (line:match("^!PR?I?N?T? (.*)$") or "") ; line="" end
      if line:find("^!R") then RELATIVE=not nil ; line="" end
      if line:find("^!A") then RELATIVE=nil     ; line="" end
      if line:find("^!D.*") then dump_connectors(CONNECTORS); line="" end
      line = line:find("#") and line:match("([^#]*)#.*$") or line
      if line:len() > 0 then process_line (CONNECTORS, line) end
      if PROMPT then io.write(PROMPT) end 
   end
   print()
end






   
   
